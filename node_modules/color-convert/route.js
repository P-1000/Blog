<<<<<<< HEAD:Server/node_modules/color-convert/route.js
var conversions = require('./conversions');

/*
	this function routes a model to all other models.
=======
const conversions = require('./conversions');

/*
	This function routes a model to all other models.
>>>>>>> f9995583c8ef31855f0b70ea32565e4b2299a09f:node_modules/color-convert/route.js

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
<<<<<<< HEAD:Server/node_modules/color-convert/route.js
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
=======
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
>>>>>>> f9995583c8ef31855f0b70ea32565e4b2299a09f:node_modules/color-convert/route.js
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
<<<<<<< HEAD:Server/node_modules/color-convert/route.js
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop
=======
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop
>>>>>>> f9995583c8ef31855f0b70ea32565e4b2299a09f:node_modules/color-convert/route.js

	graph[fromModel].distance = 0;

	while (queue.length) {
<<<<<<< HEAD:Server/node_modules/color-convert/route.js
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];
=======
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];
>>>>>>> f9995583c8ef31855f0b70ea32565e4b2299a09f:node_modules/color-convert/route.js

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
<<<<<<< HEAD:Server/node_modules/color-convert/route.js
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
=======
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
>>>>>>> f9995583c8ef31855f0b70ea32565e4b2299a09f:node_modules/color-convert/route.js
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
<<<<<<< HEAD:Server/node_modules/color-convert/route.js
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
=======
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
>>>>>>> f9995583c8ef31855f0b70ea32565e4b2299a09f:node_modules/color-convert/route.js
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

